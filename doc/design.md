# Design

`crook` is the handler between
[HGI Vault](https://github.com/wtsi-hgi/hgi-vault) and
[Shepherd](https://github.com/wtsi-hgi/shepherd), allowing the former to
pass its queue of staged files to the latter, for archiving to iRODS.
(Shepherds have crooks and crooks steal from vaults.)

It must satisfy the following design constraints, outlined in order of
increasing fidelity.

## Behaviour

1. `crook` must satisfy the interface expected by HGI Vault.

2. `crook` must manage *at most one* instance of Shepherd.

3. `crook` must manage the current capacity of iRODS.

4. `crook` must log its activity.

5. Shepherd must be forked to accommodate the needs of the archival.

## Specifics

### 1. HGI Vault Interface

`crook` must be a single executable with two modes of operation:

* One that accepts a "ready challenge" as command line parameters and
  returns an appropriate response.

* One that accepts a stream of input, representing the full paths of
  files to archive, and acts accordingly.

#### Ready Challenge and Response

The "ready challenge" will consist of two command line parameters:

1. The string `ready`.
2. An integer representing the number of bytes required to archive the
   current queue, held by HGI Vault.

For example:

    crook ready 123456

`crook` will exit immediately, using the exit code as a response
channel:

* Exit Code 0: Shepherd is idle and there is capacity to archive the
  volume of data requested.
* Exit Code 1: Shepherd is busy with a previous job.
* Exit Code 2: The requested capacity is not available.

#### Stream Input

Otherwise, `crook` will consume the input from `stdin` and interpret it
as a list of full paths to files, in `\0`-delimited plaintext, until the
end of file. These are the files that will be submitted to Shepherd for
archival, using its `submit` subcommand (see [§5](#5-shepherd-fork)).

HGI Vault does not expect nor will consume any output written to
`stdout` or `stderr` by `crook`. These channels can be freely used
(e.g., for debugging), but will clearly be lost when run in production.
To that end, expected logs must be persisted to disk (see
[§4](#4-logging)).

In this mode, `crook` must exit with the following exit codes:

* Exit Code 0: The input data was fully consumed and passed to Shepherd
  successfully.
* Exit Code 1: The above isn't true. That is:
  * Processing of the stream could not be concluded before handling to
    Shepherd.
  * Shepherd was not ready to accept a new archive batch (i.e., similar
    to a failed "ready challenge").
  * There was a problem during the hand off to Shepherd.
  * Some other problem arose.

⚠️ **`crook` *must* only exit with a successful exit code if the process
was fully successful, as this will instruct HGI Vault to irrecoverably
clear its staging queue. Ensure that *any* unexpected exit will result
in a failure exit code.**

### 2. Shepherd Management

Shepherd is a long-running process that is distributed over multiple
hosts. It is designed to not overburden any storage resource it uses,
under the assumption that only one instance is ever run at once. `crook`
must respect that assumption.

Shepherd jobs have IDs, which will need to be tracked. When a "ready
challenge" is received, `crook` must:

* Update the status of all incomplete Shepherd jobs in its tracking
  database.
* Return positively if all jobs have completed; otherwise return
  negatively.

`crook` will only ever be run serially, by a single user, so its
tracking database can be file-based (e.g., SQLite). Shepherd maintains
the files it needs to process internally, so these will *not* also need
to be maintained by `crook`.

The Shepherd job ID can be parsed out of the submission log generated by
Shepherd. This is emitted to `stderr` by Shepherd, when submitting a
job, and also written to `submit.log` in the logging directory, which is
defined by the `SHEPHERD_LOG` environment variable (defaulting to the
current working directory, if not set). (See
[`shepherd:cli.dummy.submit`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py)
for exact details on the output to parse.)

The status of a given job can be established by parsing the output of
Shepherd's `status` subcommand, which emits to `stderr`. (See
[`shepherd:cli.dummy.status`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py)
for exact details on the output to parse.)

**Note** Shepherd can recover from external failures (e.g., LSF
failure), but it cannot detect them. `crook` could heuristically detect
longer-than-expected Shepherd jobs and flag them to a human operator for
investigation, while assuming they're still running for the purposes of
the "ready challenge".

**Note** The "HGI Vault-`crook`-Shepherd" pipeline is assumed to be
independent from outside influence. As such, there is no reason for
`crook` to run as a daemon, polling the Shepherd state. It can simply
check the state on demand.

### 3. Capacity Management

When `crook` is given a "ready challenge", it must check that the
available capacity of the archival location (i.e., the Humgen iRODS
zone) exceeds that which is requested, plus a 10% threshold. For
example, if a capacity of 1000 bytes is requested, `crook` must only
respond positively if at least 1100 bytes are available.

It is not straightforward to determine the remaining space available in
an iRODS zone with icommands. It can be done with `iquest` and a
suitable query, but there is no `df`-equivalent; fortunately, ISG run
such a script and use it to populate [Graphite](https://graphiteapp.org)
-- the backend used by the metrics dashboards -- which provides a
RESTful interface. `crook` can use this interface.

**TODO** Interface details from ISG/Graphite documentation: URL, request
and response.

### 4. Logging

All logging must be persisted to disk. The following events should be
logged, with a timestamp:

* A "ready challenge" succeeded.
* A "ready challenge" failed because Shepherd was unavailable.
* A "ready challenge" failed from lack of capacity.
* A Shepherd job was started.
* A Shepherd job was determined to have completed.

Any parameters/state required to uniquely identify the logged event must
be included in the log message (e.g., the Shepherd job ID, etc.)

### 5. Shepherd Fork

As of writing, Shepherd is not yet general purpose. As such, a new
branch will need to be created from its latest release to accommodate
the needs of the archival specifically. Additionally, other changes
*could* be made to facilitate the interface (e.g., making its output
easier to parse). However, this comes at the risk of coupling the
interface too tightly, making it brittle, so care should be exercised.

#### FoFN Delimiter

Shepherd accepts a file of filenames as input to its `submit`
subcommand. However, this file is assumed to be `\n`-delimited in the
current release. However, the code exists to specify an arbitrary
delimiter (see [`shepherd:cli.dummy.prepare`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py),
which calls [`shepherd:common.models.filesystems.posix._identify_by_fofn`](https://github.com/wtsi-hgi/shepherd/blob/develop/common/models/filesystems/posix.py)).

#### Custom Route Transformer

Shepherd uses "route transformers" to modify the input and output paths
of files to archive. In the current release, the default transformers
strip the common prefix from all inputs and then add a canonical iRODS
collection prefix, parametrised by the current run, to the output path
(see [`shepherd:cli.dummy.prepare`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py)).
For example, the following:

    /path/to/my-project/file-to-archive
    /path/to/my-project/some/other-file

...would first have their common prefix stripped:

    file-to-archive
    some/other-file

...then, say, prefixed with `/humgen/archive/my_project_archive`, to
arrive at the ultimate target paths of:

    /humgen/archive/my_project_archive/file-to-archive
    /humgen/archive/my_project_archive/some/other-file

The list of files passed from `crook` (from HGI Vault's staging queue)
will be those directly from within vaults. This means, they will be
using their HGI Vault encoded path (i.e., their inode number and
base64-encoded relative path). For example:

    /path/to/my-project/.vault/.staged/01/23/45/67/89/ab-Zm9vL2Jhci9xdXV4

Moreover, if we assume general usage, these paths will be across
multiple volumes. The consequence being that the common prefix may be
`/path`, or not much lower down the hierarchy. This could result in a
final archive target path of, say:

    /humgen/archive/my_project_archive/to/my-project/.vault/.staged/01/23/45/67/89/ab-Zm9vL2Jhci9xdXV4

This is clearly less than ideal.

As such, a new route transformer would need to be added that decodes
the staged paths into something suitable. It can either run standalone,
or interact as part of a suite of transformers that already exist (see
[`shepherd:lib.planning.transformers`](https://github.com/wtsi-hgi/shepherd/blob/develop/lib/planning/transformers)).

Assuming the following anatomy of a staged file path:

    /path/to/my-project/.vault/.staged/01/23/45/67/89/ab-Zm9vL2Jhci9xdXV4
             ^^^^^^^^^^                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             PROJECT                   STAGED_ID
                               ^^^^^^^                   ^^^^^^^^^^^^^^^^
                               BRANCH                    ENCODED_PATH

* `PROJECT` is the directory immediately above the Vault directory.
* `BRANCH` is the Vault branch from where the file originates (it will
  always be `.staged`).
* `STAGED_ID` is the full staged file address (the inode ID and encoded
  path).
* `ENCODED_PATH` is the base64-encoded relative filename of the staged
  file (at time of staging).

An appropriate transformer may be something like:

    PREFIX/PROJECT/decode(ENCODED_PATH)

Where `PREFIX` is some constant prefix collection. For example, with a
prefix of `/humgen/archive`, the above would be instead transformed
into:

    /humgen/archive/my-project/foo/bar/quux

**Note** There is a possibility of naming conflict (i.e., the target
location already exists). Some strategy should be employed to remove
this.

**Note** It is possible that files will be staged from the same project
across multiple disks. The above suggested transformer would collapse
all paths into the same location, which would increase the risk of
naming conflict, regardless of the above strategy; thus requiring an
*additional* strategy.

For example, the following would avoid all conflicts:

    PREFIX/PROJECT/VOLUME/ARCHIVE_DATE/decode(ENCODED_PATH)

...however, it is at the expense of clarity as the `VOLUME` and
`ARCHIVE_DATE` don't provide any useful semantic information beyond
disambiguation. With that in mind, the design of the conflict resolution
strategies must be carefully considered as a group.

#### Metadata

Shepherd applies metadata to a whole batch of files, per run, based on a
provided JSON file (see [`shepherd:cli.dummy.transfer`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py)).
For the purpose of the archival, this could be hardcoded in some way,
along with any additional metadata that may be useful.

#### Deleting Staged Source Files

Shepherd does not delete source files once they have been transferred to
their target. It is important that this is done, post-verification, in
this case, or the staged files will remain in their respective vaults
forever.

## Suggestions for Production

* Create a new repository in Sanger's internal GitLab.
* Submodule into that repository:
  * This repository;
  * Shepherd, checked out at the new branch with the above changes.

You can then use this repository to set up, for example:

* Wrapper scripts, to set environment variables, etc. and start `crook`
  (and subsequently, Shepherd; see [`shepherd:cli.dummy.main`](https://github.com/wtsi-hgi/shepherd/blob/develop/cli/dummy.py)
  for details of its necessary state).

* Canonical locations for:
  * `crook`'s log;
  * Shepherd's logs;
  * `metadata.json`, if necessary (see [above](#metadata));
  * `crook`'s tracking database;
  * The FoFNs used to drive Shepherd as they come out of HGI Vault,
    either temporarily, or permanently as there is some value in keeping
    them.

* Sanger-specific documentation.

See the [Shepherd testing repository](https://gitlab.internal.sanger.ac.uk/hgi/shepherd-testing)
(internal only) for precedent of this approach.
